✅ **بخش اول: هدف، معرفی، و ساختار ماژول `core/`**  

📌 **هدف این بخش:**  
- **معرفی ماژول `core/`** و نقش کلیدی آن در سیستم  
- **تشریح ساختار کلی** که در پیاده‌سازی رعایت شده است  
- **توضیح نحوه‌ی هماهنگی ماژول‌های داخلی `core/` با یکدیگر**  

🚀 **این بخش مقدمه‌ای برای مستندات ماژول `core/` خواهد بود.**  

---

### **📜 مستندات `core/` - بخش اول: معرفی و ساختار کلی**
```md
# 📌 مستندات ماژول `core/` در Smart Whale AI

## 1️⃣ مقدمه
ماژول `core/` هسته‌ی اصلی سیستم **Smart Whale AI** است که شامل مکانیزم‌های پایه‌ای و زیرساخت‌های پردازشی می‌شود. این ماژول تمامی قابلیت‌های اساسی برای **مدیریت حافظه، پردازش، یادگیری فدراسیونی، مدیریت منابع، کنترل کیفیت، و مانیتورینگ سیستم** را فراهم می‌کند.

این ماژول **بر اساس رویکرد "کمترین پردازش، بهترین نتیجه" طراحی شده است** و تضمین می‌کند که تمام فرآیندهای پردازشی سیستم **با کمترین مصرف منابع و بالاترین کارایی اجرا شوند**.

## 2️⃣ نقش ماژول `core/` در سیستم
**ماژول `core/` مسئولیت مدیریت زیرساخت‌های کلیدی سیستم را بر عهده دارد، از جمله:**
- **پردازش درخواست‌ها** و **مدیریت منابع پردازشی** (CPU، GPU، حافظه)
- **مدیریت هوشمند حافظه** شامل **کش چندسطحی و ذخیره‌سازی کوانتومی**
- **یادگیری فدراسیونی** و **مدیریت هماهنگی مدل‌های توزیع‌شده**
- **کنترل کیفیت خروجی مدل‌ها** و **تحلیل متریک‌های عملکردی**
- **مدیریت داده‌های مانیتورینگ سیستم** برای **تحلیل روند و شناسایی ناهنجاری‌ها**

---

## 3️⃣ ساختار ماژول `core/`
ماژول `core/` شامل **۷ بخش اصلی** است که هر کدام مسئولیت خاصی دارند:

```plaintext
core/
├── base/                      # کلاس‌های پایه و اینترفیس‌های استاندارد
├── memory/                    # مدیریت حافظه و کش چندسطحی
├── federation/                # یادگیری فدراسیونی و مدیریت مدل‌های توزیع‌شده
├── monitoring/                # پایش عملکرد و کیفیت مدل‌ها
├── processing/                # مدیریت پردازش درخواست‌ها و تخصیص منابع پردازشی
├── quality/                   # کنترل کیفیت، بهینه‌سازی، و تحلیل متریک‌های کیفیت مدل‌ها
└── resource_management/        # مدیریت منابع پردازشی، تخصیص منابع، و توزیع بار
```

### 📌 **توضیح هر بخش به‌صورت خلاصه:**
✅ **`base/`** → شامل کلاس‌های پایه و اینترفیس‌های استاندارد برای تعامل ماژول‌های `core/`  
✅ **`memory/`** → مدیریت کش، حافظه چندسطحی، و بهینه‌سازی ذخیره‌سازی داده‌های مدل‌ها  
✅ **`federation/`** → پیاده‌سازی یادگیری فدراسیونی، هماهنگی مدل‌های توزیع‌شده، و مدیریت دانش بین مدل‌ها  
✅ **`monitoring/`** → پایش عملکرد مدل‌ها، نظارت بر کیفیت یادگیری، و شناسایی ناهنجاری‌ها  
✅ **`processing/`** → مدیریت درخواست‌های پردازشی، تخصیص منابع، و بهینه‌سازی مسیر پردازش  
✅ **`quality/`** → تحلیل کیفیت مدل‌ها، ارزیابی عملکرد، و بهینه‌سازی پاسخ‌های تولیدشده  
✅ **`resource_management/`** → مدیریت منابع پردازشی شامل CPU، GPU، و حافظه، تخصیص منابع، و کنترل بار پردازشی  

---

## 4️⃣ ارتباط ماژول `core/` با سایر بخش‌های سیستم
### 🔗 **ارتباط با `models/`**
- ماژول `core/` به‌عنوان زیرساخت **تمامی مدل‌های هوش مصنوعی در `models/` را مدیریت می‌کند**.
- **`processing/`** درخواست‌های ورودی مدل‌ها را مدیریت و پردازش می‌کند.
- **`memory/`** داده‌های پردازشی مدل‌ها را در کش ذخیره و بازیابی می‌کند.
- **`federation/`** یادگیری بین مدل‌های مختلف را هماهنگ می‌کند.

### 🔗 **ارتباط با `data/`**
- ماژول `core/` داده‌های ورودی و خروجی مدل‌ها را از طریق **`memory/` و `processing/`** مدیریت می‌کند.
- **`resource_management/`** منابع موردنیاز برای پردازش داده‌ها را مدیریت می‌کند.

### 🔗 **ارتباط با `infrastructure/`**
- ماژول `core/` با سیستم‌های ذخیره‌سازی (`MinIO`)، پایگاه داده‌ی متریک‌ها (`TimescaleDB`)، و سیستم کش (`Redis`) هماهنگ است.
- **`monitoring/`** داده‌های متریک عملکردی مدل‌ها را در `TimescaleDB` ذخیره و تحلیل می‌کند.
- **`resource_management/`** درخواست‌های پردازشی را در `Redis` برای هماهنگی بهتر کش می‌کند.

---

## 🎯 نتیجه‌گیری
ماژول `core/` **مغز پردازشی سیستم Smart Whale AI است** که با **مدیریت بهینه‌ی منابع و پردازش هوشمند داده‌ها، امکان اجرای مدل‌های هوش مصنوعی را با بالاترین کارایی و کمترین مصرف منابع فراهم می‌کند.**  

🚀 **در بخش‌های بعدی، هر یک از این ماژول‌ها را به‌صورت جداگانه بررسی خواهیم کرد و توضیحات کاملی درباره کلاس‌ها، متدها، و مکانیزم‌های داخلی آن ارائه خواهیم داد.**  
```

---

✅ **بخش دوم: مستندات `core/base/` (کلاس‌های پایه و اینترفیس‌های استاندارد)**  

📌 **هدف این بخش:**  
- **بررسی ماژول `base/` و نقش آن در `core/`**  
- **توضیح ساختار فایل‌های `base/`**  
- **شرح کلاس‌های پایه، اینترفیس‌ها، و متدهای کلیدی**  

🚀 **این بخش، ستون فقرات سیستم را توضیح می‌دهد که سایر ماژول‌های `core/` بر پایه‌ی آن ساخته شده‌اند.**  

---

### **📜 مستندات `core/base/`**
```md
# 📌 مستندات `core/base/` - کلاس‌های پایه و اینترفیس‌های استاندارد

## 1️⃣ مقدمه
ماژول `core/base/` شامل **کلاس‌های پایه** و **رابط‌های استاندارد** است که **به‌عنوان زیرساختی برای تمامی ماژول‌های `core/` عمل می‌کند.**  
این ماژول، استانداردهای لازم برای **تعامل بین بخش‌های مختلف سیستم** را تعریف کرده و از **یکپارچگی پردازش‌ها و منابع** اطمینان حاصل می‌کند.

---

## 2️⃣ نقش `base/` در سیستم
ماژول `base/` به‌عنوان **لایه‌ی زیربنایی** برای تمامی ماژول‌های `core/` عمل کرده و شامل **کلاس‌های پایه‌ای برای مدل‌ها، پردازشگرها، و اینترفیس‌های استاندارد** است.  

### 📌 **وظایف کلیدی `base/`**
- **تعریف استانداردهای پردازش مدل‌ها** (با استفاده از `BaseModel` و `BaseProcessor`)
- **ایجاد اینترفیس‌های استاندارد** برای هماهنگ‌سازی پردازش‌های فدراسیونی (`ModelInterface` و `ProcessorInterface`)
- **مدیریت منابع پردازشی** و تعریف قراردادهای استاندارد (`ResourceAware`)

---

## 3️⃣ ساختار `core/base/`
```plaintext
core/
└── base/
    ├── model.py                 # کلاس پایه برای تمامی مدل‌های هوش مصنوعی
    ├── processor.py              # کلاس پایه برای پردازشگرهای مدل‌ها
    ├── interfaces/               # اینترفیس‌های استاندارد
    │   ├── model_interface.py    # استانداردسازی تعامل مدل‌ها
    │   ├── processor_interface.py # استانداردسازی رفتار پردازشگرها
    │   └── resource_aware.py     # مدیریت منابع پردازشی
```

---

## 4️⃣ بررسی فایل‌های `base/`

### 📍 **`model.py` - کلاس پایه‌ی مدل‌های هوش مصنوعی**
این فایل شامل **کلاس `BaseModel`** است که تمامی مدل‌های فدراسیونی از آن ارث‌بری می‌کنند.  
📌 **ویژگی‌های `BaseModel`**  
✅ **مدیریت ورژن و تنظیمات مدل**  
✅ **امکان ذخیره و بازیابی وضعیت مدل**  
✅ **متد پایه‌ی `process(input_data)` برای پردازش ورودی‌ها**  

```python
class BaseModel(ABC):
    """
    کلاس پایه برای تمامی مدل‌های هوش مصنوعی.
    """

    def __init__(self, model_name: str, version: str, config: Optional[Dict[str, Any]] = None):
        self.model_name = model_name
        self.version = version
        self.config = config if config else {}
        self.status = "initialized"
```

---

### 📍 **`processor.py` - کلاس پایه‌ی پردازشگرهای مدل‌ها**
این فایل شامل **کلاس `BaseProcessor`** است که پردازش‌های ورودی مدل‌ها را مدیریت می‌کند.  
📌 **ویژگی‌های `BaseProcessor`**  
✅ **اجرای پردازش‌های مدل به‌صورت ناهمزمان (`async`)**  
✅ **مدیریت منابع پردازشی موردنیاز برای هر وظیفه**  
✅ **ثبت زمان پردازش و نظارت بر عملکرد پردازش‌ها**  

```python
class BaseProcessor(ABC):
    """
    کلاس پایه برای پردازش مدل‌ها.
    """

    async def process(self, input_data: Any) -> Any:
        """
        متد پردازش داده که باید در کلاس‌های فرزند پیاده‌سازی شود.
        """
        pass
```

---

### 📍 **`interfaces/` - اینترفیس‌های استاندارد**
این بخش شامل سه فایل مهم برای استانداردسازی تعاملات سیستم است:  

1️⃣ **`model_interface.py`** → اینترفیس پایه برای تعامل مدل‌های فدراسیونی  
📌 **ویژگی‌ها:**  
✅ **تعریف متد `process(input_data)` برای پردازش داده‌ها**  
✅ **امکان ذخیره و بازیابی وضعیت مدل‌ها**  
✅ **دریافت وضعیت فعلی مدل**  

```python
class ModelInterface(ABC):
    """
    اینترفیس استاندارد برای تمامی مدل‌های هوش مصنوعی.
    """

    @abstractmethod
    def process(self, input_data: Any) -> Any:
        pass
```

---

2️⃣ **`processor_interface.py`** → اینترفیس استاندارد برای پردازشگرهای مدل‌ها  
📌 **ویژگی‌ها:**  
✅ **اجرای پردازش داده‌ها به‌صورت ناهمزمان (`async`)**  
✅ **مدیریت منابع پردازشی موردنیاز برای هر وظیفه**  
✅ **امکان دریافت وضعیت پردازش‌ها**  

```python
class ProcessorInterface(ABC):
    """
    اینترفیس استاندارد برای پردازشگرهای مدل‌ها.
    """

    @abstractmethod
    async def process(self, input_data: Any) -> Any:
        pass
```

---

3️⃣ **`resource_aware.py`** → اینترفیس استاندارد برای مدیریت منابع پردازشی  
📌 **ویژگی‌ها:**  
✅ **مدیریت تخصیص منابع پردازشی (`CPU`، `Memory`، `GPU`)**  
✅ **امکان آزادسازی منابع پس از اتمام پردازش**  
✅ **دریافت وضعیت منابع پردازشی مدل‌ها**  

```python
class ResourceAware(ABC):
    """
    اینترفیس استاندارد برای مدیریت منابع مدل‌ها و پردازشگرها.
    """

    @abstractmethod
    def allocate_resources(self, cpu: float, memory: float, gpu: float = 0.0):
        pass
```

---

## 🎯 **نتیجه‌گیری**
ماژول `base/` **هسته‌ی اصلی `core/` را تشکیل می‌دهد و تمامی استانداردهای موردنیاز برای هماهنگی بین بخش‌های مختلف سیستم را تعریف می‌کند.**  
✅ **`BaseModel` و `BaseProcessor`، پایه‌ای برای تمامی مدل‌ها و پردازشگرها هستند.**  
✅ **اینترفیس‌های `ModelInterface`، `ProcessorInterface` و `ResourceAware`، استانداردهای تعامل سیستم را مشخص می‌کنند.**  

🚀 **در بخش‌های بعدی، هر یک از ماژول‌های `core/` را به‌صورت جداگانه بررسی خواهیم کرد و توضیحات کاملی درباره کلاس‌ها، متدها، و مکانیزم‌های داخلی آن ارائه خواهیم داد.**  
```

---

✅ **بخش دوم: مستندات `core/base/` (کلاس‌های پایه و اینترفیس‌های استاندارد)**  

📌 **هدف این بخش:**  
- **بررسی ماژول `base/` و نقش آن در `core/`**  
- **توضیح ساختار فایل‌های `base/`**  
- **شرح کلاس‌های پایه، اینترفیس‌ها، و متدهای کلیدی**  

🚀 **این بخش، ستون فقرات سیستم را توضیح می‌دهد که سایر ماژول‌های `core/` بر پایه‌ی آن ساخته شده‌اند.**  

---

### **📜 مستندات `core/base/`**
```md
# 📌 مستندات `core/base/` - کلاس‌های پایه و اینترفیس‌های استاندارد

## 1️⃣ مقدمه
ماژول `core/base/` شامل **کلاس‌های پایه** و **رابط‌های استاندارد** است که **به‌عنوان زیرساختی برای تمامی ماژول‌های `core/` عمل می‌کند.**  
این ماژول، استانداردهای لازم برای **تعامل بین بخش‌های مختلف سیستم** را تعریف کرده و از **یکپارچگی پردازش‌ها و منابع** اطمینان حاصل می‌کند.

---

## 2️⃣ نقش `base/` در سیستم
ماژول `base/` به‌عنوان **لایه‌ی زیربنایی** برای تمامی ماژول‌های `core/` عمل کرده و شامل **کلاس‌های پایه‌ای برای مدل‌ها، پردازشگرها، و اینترفیس‌های استاندارد** است.  

### 📌 **وظایف کلیدی `base/`**
- **تعریف استانداردهای پردازش مدل‌ها** (با استفاده از `BaseModel` و `BaseProcessor`)
- **ایجاد اینترفیس‌های استاندارد** برای هماهنگ‌سازی پردازش‌های فدراسیونی (`ModelInterface` و `ProcessorInterface`)
- **مدیریت منابع پردازشی** و تعریف قراردادهای استاندارد (`ResourceAware`)

---

## 3️⃣ ساختار `core/base/`
```plaintext
core/
└── base/
    ├── model.py                 # کلاس پایه برای تمامی مدل‌های هوش مصنوعی
    ├── processor.py              # کلاس پایه برای پردازشگرهای مدل‌ها
    ├── interfaces/               # اینترفیس‌های استاندارد
    │   ├── model_interface.py    # استانداردسازی تعامل مدل‌ها
    │   ├── processor_interface.py # استانداردسازی رفتار پردازشگرها
    │   └── resource_aware.py     # مدیریت منابع پردازشی
```

---

## 4️⃣ بررسی فایل‌های `base/`

### 📍 **`model.py` - کلاس پایه‌ی مدل‌های هوش مصنوعی**
این فایل شامل **کلاس `BaseModel`** است که تمامی مدل‌های فدراسیونی از آن ارث‌بری می‌کنند.  
📌 **ویژگی‌های `BaseModel`**  
✅ **مدیریت ورژن و تنظیمات مدل**  
✅ **امکان ذخیره و بازیابی وضعیت مدل**  
✅ **متد پایه‌ی `process(input_data)` برای پردازش ورودی‌ها**  

```python
class BaseModel(ABC):
    """
    کلاس پایه برای تمامی مدل‌های هوش مصنوعی.
    """

    def __init__(self, model_name: str, version: str, config: Optional[Dict[str, Any]] = None):
        self.model_name = model_name
        self.version = version
        self.config = config if config else {}
        self.status = "initialized"
```

---

### 📍 **`processor.py` - کلاس پایه‌ی پردازشگرهای مدل‌ها**
این فایل شامل **کلاس `BaseProcessor`** است که پردازش‌های ورودی مدل‌ها را مدیریت می‌کند.  
📌 **ویژگی‌های `BaseProcessor`**  
✅ **اجرای پردازش‌های مدل به‌صورت ناهمزمان (`async`)**  
✅ **مدیریت منابع پردازشی موردنیاز برای هر وظیفه**  
✅ **ثبت زمان پردازش و نظارت بر عملکرد پردازش‌ها**  

```python
class BaseProcessor(ABC):
    """
    کلاس پایه برای پردازش مدل‌ها.
    """

    async def process(self, input_data: Any) -> Any:
        """
        متد پردازش داده که باید در کلاس‌های فرزند پیاده‌سازی شود.
        """
        pass
```

---

### 📍 **`interfaces/` - اینترفیس‌های استاندارد**
این بخش شامل سه فایل مهم برای استانداردسازی تعاملات سیستم است:  

1️⃣ **`model_interface.py`** → اینترفیس پایه برای تعامل مدل‌های فدراسیونی  
📌 **ویژگی‌ها:**  
✅ **تعریف متد `process(input_data)` برای پردازش داده‌ها**  
✅ **امکان ذخیره و بازیابی وضعیت مدل‌ها**  
✅ **دریافت وضعیت فعلی مدل**  

```python
class ModelInterface(ABC):
    """
    اینترفیس استاندارد برای تمامی مدل‌های هوش مصنوعی.
    """

    @abstractmethod
    def process(self, input_data: Any) -> Any:
        pass
```

---

2️⃣ **`processor_interface.py`** → اینترفیس استاندارد برای پردازشگرهای مدل‌ها  
📌 **ویژگی‌ها:**  
✅ **اجرای پردازش داده‌ها به‌صورت ناهمزمان (`async`)**  
✅ **مدیریت منابع پردازشی موردنیاز برای هر وظیفه**  
✅ **امکان دریافت وضعیت پردازش‌ها**  

```python
class ProcessorInterface(ABC):
    """
    اینترفیس استاندارد برای پردازشگرهای مدل‌ها.
    """

    @abstractmethod
    async def process(self, input_data: Any) -> Any:
        pass
```

---

3️⃣ **`resource_aware.py`** → اینترفیس استاندارد برای مدیریت منابع پردازشی  
📌 **ویژگی‌ها:**  
✅ **مدیریت تخصیص منابع پردازشی (`CPU`، `Memory`، `GPU`)**  
✅ **امکان آزادسازی منابع پس از اتمام پردازش**  
✅ **دریافت وضعیت منابع پردازشی مدل‌ها**  

```python
class ResourceAware(ABC):
    """
    اینترفیس استاندارد برای مدیریت منابع مدل‌ها و پردازشگرها.
    """

    @abstractmethod
    def allocate_resources(self, cpu: float, memory: float, gpu: float = 0.0):
        pass
```

---

## 🎯 **نتیجه‌گیری**
ماژول `base/` **هسته‌ی اصلی `core/` را تشکیل می‌دهد و تمامی استانداردهای موردنیاز برای هماهنگی بین بخش‌های مختلف سیستم را تعریف می‌کند.**  
✅ **`BaseModel` و `BaseProcessor`، پایه‌ای برای تمامی مدل‌ها و پردازشگرها هستند.**  
✅ **اینترفیس‌های `ModelInterface`، `ProcessorInterface` و `ResourceAware`، استانداردهای تعامل سیستم را مشخص می‌کنند.**  



✅ **بخش چهارم: مستندات `core/federation/` (یادگیری فدراسیونی، هماهنگی مدل‌ها، و مدیریت دانش)**  

📌 **هدف این بخش:**  
- **بررسی ماژول `federation/` و نقش آن در `core/`**  
- **توضیح ساختار فایل‌های `federation/`**  
- **شرح کلاس‌های کلیدی، متدها، و مکانیزم‌های یادگیری فدراسیونی**  

🚀 **این بخش، سیستم یادگیری فدراسیونی را توضیح می‌دهد که شامل هماهنگ‌سازی مدل‌ها، اشتراک دانش، و پردازش فدراسیونی است.**  

---

### **📜 مستندات `core/federation/`**
```md
# 📌 مستندات `core/federation/` - یادگیری فدراسیونی و هماهنگی مدل‌ها

## 1️⃣ مقدمه
ماژول `core/federation/` مسئول **مدیریت یادگیری فدراسیونی در بین مدل‌های هوش مصنوعی** است و تضمین می‌کند که **مدل‌ها می‌توانند دانش خود را به اشتراک بگذارند، هماهنگ شوند، و بدون نیاز به تمرکز داده‌ها، یادگیری را بهینه کنند.**  

---

## 2️⃣ نقش `federation/` در سیستم
این ماژول **یادگیری توزیع‌شده و هماهنگ‌سازی بین مدل‌های هوش مصنوعی** را مدیریت می‌کند و شامل بخش‌های زیر است:  
📌 **وظایف کلیدی `federation/`**  
✅ **مسیریابی و مدیریت توزیع درخواست‌ها بین مدل‌های فدراسیونی**  
✅ **مدیریت و بهینه‌سازی اشتراک دانش بین مدل‌های یادگیرنده**  
✅ **هماهنگی بین مدل‌های فدراسیونی برای پردازش درخواست‌ها**  
✅ **یادگیری فدراسیونی برای ترکیب و بهبود مدل‌ها بدون تمرکز داده‌ها**  
✅ **پایش عملکرد، کیفیت، و امنیت مدل‌های فدراسیونی**  

---

## 3️⃣ ساختار `core/federation/`
```plaintext
core/
└── federation/
    ├── routing/                  # مسیریابی درخواست‌های فدراسیونی
    │   ├── request_dispatcher.py      # مسیریابی و توزیع درخواست‌ها بین مدل‌های فدراسیونی
    │   ├── load_balancer.py           # مدیریت تعادل بار بین مدل‌ها
    │   ├── route_optimizer.py         # بهینه‌سازی مسیرهای پردازش
    │
    ├── knowledge_sharing/         # مدیریت اشتراک و تبادل دانش بین مدل‌ها
    │   ├── knowledge_manager.py       # ذخیره‌سازی و بازیابی دانش بین مدل‌های فدراسیونی
    │   ├── privacy_guard.py           # حفظ امنیت و حریم خصوصی در انتقال دانش
    │
    ├── orchestration/             # هماهنگی پردازش‌ها و مدیریت منابع بین مدل‌های فدراسیونی
    │   ├── model_coordinator.py       # هماهنگ‌کننده مدل‌های فدراسیونی
    │   ├── task_manager.py            # مدیریت وظایف و توزیع پردازش‌ها بین مدل‌ها
    │
    ├── learning/                  # یادگیری فدراسیونی و ترکیب دانش مدل‌ها
    │   ├── federated_learner.py       # مدیریت چرخه یادگیری فدراسیونی
    │   ├── model_aggregator.py        # تجمیع اطلاعات و وزن‌های مدل‌ها
    │   ├── learning_optimizer.py      # بهینه‌سازی فرآیند یادگیری فدراسیونی
    │
    ├── monitoring/                # پایش عملکرد و نظارت بر فرآیندهای فدراسیونی
    │   ├── performance_monitor.py     # پایش کارایی مدل‌ها و منابع
    │   ├── quality_monitor.py         # تحلیل کیفیت و دقت مدل‌ها
    │
    ├── security/                  # تضمین امنیت و کنترل دسترسی در فدراسیون
    │   ├── access_control.py          # مدیریت سطح دسترسی مدل‌ها و کنترل مجوزها
    │   ├── integrity_checker.py       # بررسی صحت داده‌های اشتراکی
```

---

## 4️⃣ بررسی فایل‌های `federation/`

### 📍 **`routing/` - مدیریت مسیریابی بین مدل‌های فدراسیونی**
📌 **ویژگی‌های کلیدی:**  
✅ **`request_dispatcher.py`** → توزیع درخواست‌ها بین مدل‌های فدراسیونی  
✅ **`load_balancer.py`** → مدیریت تعادل بار بین مدل‌های پردازشی  
✅ **`route_optimizer.py`** → بهینه‌سازی مسیر پردازش و ارسال درخواست‌ها  

---

### 📍 **`knowledge_sharing/` - اشتراک دانش بین مدل‌ها**
📌 **ویژگی‌های کلیدی:**  
✅ **`knowledge_manager.py`** → ذخیره‌سازی و مدیریت دانش بین مدل‌های فدراسیونی  
✅ **`privacy_guard.py`** → محافظت از داده‌های حساس در هنگام اشتراک دانش  

---

### 📍 **`orchestration/` - هماهنگی بین مدل‌ها**
📌 **ویژگی‌های کلیدی:**  
✅ **`model_coordinator.py`** → هماهنگ‌سازی پردازش‌های بین مدل‌ها  
✅ **`task_manager.py`** → مدیریت وظایف پردازشی در سیستم فدراسیونی  

---

### 📍 **`learning/` - یادگیری فدراسیونی و تجمیع مدل‌ها**
📌 **ویژگی‌های کلیدی:**  
✅ **`federated_learner.py`** → مدیریت یادگیری فدراسیونی و جمع‌آوری به‌روزرسانی‌ها  
✅ **`model_aggregator.py`** → ترکیب و تجمیع وزن‌های مدل‌های فدراسیونی  
✅ **`learning_optimizer.py`** → بهینه‌سازی فرآیند یادگیری و تنظیم نرخ یادگیری  

---

### 📍 **`monitoring/` - پایش عملکرد و نظارت بر مدل‌های فدراسیونی**
📌 **ویژگی‌های کلیدی:**  
✅ **`performance_monitor.py`** → بررسی عملکرد مدل‌ها و مصرف منابع  
✅ **`quality_monitor.py`** → تحلیل کیفیت خروجی مدل‌ها و شناسایی افت کیفیت  

---

### 📍 **`security/` - تضمین امنیت و بررسی یکپارچگی داده‌ها**
📌 **ویژگی‌های کلیدی:**  
✅ **`access_control.py`** → مدیریت سطح دسترسی مدل‌ها و مجوزهای ارتباطی  
✅ **`integrity_checker.py`** → بررسی صحت و یکپارچگی داده‌های فدراسیونی  

---

## 🎯 **نتیجه‌گیری**
ماژول `federation/` **هسته‌ی سیستم یادگیری فدراسیونی را تشکیل می‌دهد و تمامی قابلیت‌های موردنیاز برای پردازش توزیع‌شده‌ی مدل‌ها را فراهم می‌کند.**  
✅ **`routing/` مسئول مسیریابی و توزیع درخواست‌ها است.**  
✅ **`knowledge_sharing/` مدیریت انتقال و ذخیره دانش بین مدل‌ها را انجام می‌دهد.**  
✅ **`orchestration/` هماهنگی بین مدل‌ها و پردازش‌های فدراسیونی را مدیریت می‌کند.**  
✅ **`learning/` مکانیزم‌های یادگیری فدراسیونی و ترکیب مدل‌ها را کنترل می‌کند.**  
✅ **`monitoring/` عملکرد مدل‌ها را تحلیل کرده و کیفیت پردازش را ارزیابی می‌کند.**  
✅ **`security/` امنیت و یکپارچگی داده‌های فدراسیونی را تضمین می‌کند.**  



✅ **بخش پنجم: مستندات `core/monitoring/` (پایش عملکرد و نظارت بر سیستم)**  

📌 **هدف این بخش:**  
- **بررسی ماژول `monitoring/` و نقش آن در `core/`**  
- **توضیح ساختار فایل‌های `monitoring/`**  
- **شرح کلاس‌های کلیدی، متدها، و مکانیزم‌های پایش عملکرد مدل‌ها**  

🚀 **این بخش، سیستم مانیتورینگ را توضیح می‌دهد که برای نظارت بر عملکرد، کیفیت، و سلامت مدل‌های هوش مصنوعی طراحی شده است.**  

---

### **📜 مستندات `core/monitoring/`**
```md
# 📌 مستندات `core/monitoring/` - پایش عملکرد و نظارت بر مدل‌ها

## 1️⃣ مقدمه
ماژول `core/monitoring/` مسئول **پایش عملکرد مدل‌های هوش مصنوعی، نظارت بر کیفیت پردازش، و شناسایی ناهنجاری‌های سیستم** است. این ماژول داده‌های متریک عملکرد را ثبت کرده و از آن‌ها برای **تحلیل روندها و بهینه‌سازی مدل‌ها** استفاده می‌کند.

---

## 2️⃣ نقش `monitoring/` در سیستم
📌 **وظایف کلیدی `monitoring/`**  
✅ **جمع‌آوری و تحلیل داده‌های عملکردی مدل‌های هوش مصنوعی**  
✅ **شناسایی ناهنجاری‌ها و کاهش عملکرد در مدل‌های فدراسیونی**  
✅ **پایش مصرف منابع پردازشی (CPU، حافظه، GPU) و کنترل بار پردازشی سیستم**  
✅ **مدیریت و ارسال هشدارها برای رفع مشکلات عملکردی مدل‌ها**  
✅ **ارائه‌ی داشبوردهای تحلیلی برای مشاهده و بررسی وضعیت مدل‌های پردازشی**  

---

## 3️⃣ ساختار `core/monitoring/`
```plaintext
core/
└── monitoring/
    ├── metrics/                # تحلیل متریک‌های عملکردی مدل‌ها
    │   ├── performance_metrics.py   # ثبت و تحلیل متریک‌های دقت، تأخیر، و مصرف منابع
    │
    ├── health/                 # بررسی سلامت و وضعیت سیستم
    │   ├── health_checker.py        # پایش سلامت مدل‌های پردازشی
    │   ├── anomaly_detector.py      # شناسایی ناهنجاری‌های پردازشی
    │
    ├── visualization/           # نمایش اطلاعات مانیتورینگ و داشبوردها
    │   ├── dashboard_generator.py   # ایجاد داشبوردهای تحلیلی برای مشاهده‌ی عملکرد مدل‌ها
    │   ├── alert_visualizer.py      # نمایش هشدارهای سیستم در داشبورد
```

---

## 4️⃣ بررسی فایل‌های `monitoring/`

### 📍 **`metrics/` - تحلیل متریک‌های عملکردی**
📌 **ویژگی‌های کلیدی:**  
✅ **`performance_metrics.py`** → جمع‌آوری متریک‌های دقت، تأخیر، و مصرف منابع مدل‌های فدراسیونی  

---

### 📍 **`health/` - پایش سلامت مدل‌ها و شناسایی ناهنجاری‌ها**
📌 **ویژگی‌های کلیدی:**  
✅ **`health_checker.py`** → بررسی وضعیت سلامت مدل‌های پردازشی و نظارت بر تغییرات عملکرد  
✅ **`anomaly_detector.py`** → تشخیص ناهنجاری‌های پردازشی و ارسال هشدارها  

---

### 📍 **`visualization/` - نمایش داده‌های مانیتورینگ**
📌 **ویژگی‌های کلیدی:**  
✅ **`dashboard_generator.py`** → تولید داشبوردهای مانیتورینگ برای مشاهده‌ی داده‌های عملکردی  
✅ **`alert_visualizer.py`** → نمایش هشدارهای مربوط به مشکلات پردازشی در سیستم  

---

## 🎯 **نتیجه‌گیری**
ماژول `monitoring/` **وظیفه‌ی پایش عملکرد مدل‌های هوش مصنوعی، نظارت بر کیفیت پردازش، و مدیریت هشدارها را بر عهده دارد.**  
✅ **`metrics/` مسئول جمع‌آوری و تحلیل متریک‌های عملکردی مدل‌ها است.**  
✅ **`health/` سلامت مدل‌های پردازشی را بررسی کرده و ناهنجاری‌ها را شناسایی می‌کند.**  
✅ **`visualization/` داشبوردهای تحلیلی برای مشاهده‌ی وضعیت سیستم را مدیریت می‌کند.**  


✅ **بخش ششم: مستندات `core/processing/` (مدیریت پردازش درخواست‌ها و تخصیص منابع)**  

📌 **هدف این بخش:**  
- **بررسی ماژول `processing/` و نقش آن در `core/`**  
- **توضیح ساختار فایل‌های `processing/`**  
- **شرح کلاس‌های کلیدی، متدها، و مکانیزم‌های پردازشی**  

🚀 **این بخش، سیستم پردازش درخواست‌ها و تخصیص منابع پردازشی را توضیح می‌دهد که یکی از اجزای کلیدی در اجرای مدل‌های هوش مصنوعی است.**  

---

### **📜 مستندات `core/processing/`**
```md
# 📌 مستندات `core/processing/` - مدیریت پردازش درخواست‌ها و تخصیص منابع

## 1️⃣ مقدمه
ماژول `core/processing/` مسئول **مدیریت پردازش درخواست‌های مدل‌های هوش مصنوعی** است.  
این ماژول تضمین می‌کند که **درخواست‌ها بر اساس سطح پیچیدگی پردازش شده، منابع بهینه تخصیص داده شوند، و زمان اجرای وظایف حداقل باشد.**

---

## 2️⃣ نقش `processing/` در سیستم
📌 **وظایف کلیدی `processing/`**  
✅ **مدیریت پردازش درخواست‌ها در سه سطح: سریع، استاندارد، عمیق**  
✅ **تخصیص منابع پردازشی بر اساس پیچیدگی پردازش و بار کاری سیستم**  
✅ **هماهنگی با `TaskScheduler` برای زمان‌بندی وظایف پردازشی**  
✅ **بهینه‌سازی مسیرهای پردازش و اجرای بهینه درخواست‌ها**  

---

## 3️⃣ ساختار `core/processing/`
```plaintext
core/
└── processing/
    ├── pipeline.py                # مدیریت فرآیندهای پردازش و کنترل جریان داده
    ├── task_scheduler.py          # زمان‌بندی وظایف پردازشی بر اساس بار کاری
    ├── optimizer.py               # بهینه‌سازی تخصیص منابع و مسیرهای پردازش
```

---

## 4️⃣ بررسی فایل‌های `processing/`

### 📍 **`pipeline.py` - مدیریت فرآیندهای پردازشی**
📌 **ویژگی‌های کلیدی:**  
✅ **اجرای پردازش چندسطحی شامل `quick`, `normal`, و `deep`**  
✅ **مدیریت داده‌های ورودی و کنترل جریان پردازش**  
✅ **هماهنگی با `TaskScheduler` و `ProcessingOptimizer` برای اجرای بهینه وظایف**  

```python
class ProcessingPipeline:
    def process_request(self, request: Dict[str, Any]) -> Dict[str, Any]:
        """ مدیریت و اجرای پردازش بر اساس سطح پیچیدگی درخواست. """
```

---

### 📍 **`task_scheduler.py` - زمان‌بندی وظایف پردازشی**
📌 **ویژگی‌های کلیدی:**  
✅ **مدیریت صف وظایف پردازشی و تخصیص آن‌ها به مدل‌های پردازشی**  
✅ **بررسی منابع در دسترس و جلوگیری از اضافه‌بار پردازشی**  
✅ **هماهنگی با `ProcessingOptimizer` برای تخصیص منابع بهینه**  

```python
class TaskScheduler:
    def schedule_task(self, task: Dict[str, Any]):
        """ اضافه کردن یک وظیفه به صف پردازش. """
```

---

### 📍 **`optimizer.py` - بهینه‌سازی تخصیص منابع و مسیرهای پردازش**
📌 **ویژگی‌های کلیدی:**  
✅ **تخصیص منابع پردازشی (CPU، حافظه، GPU) بر اساس پیچیدگی وظایف**  
✅ **پیش‌بینی میزان بار کاری آینده و تنظیم پویا منابع پردازشی**  
✅ **هماهنگی با `TaskScheduler` و `ProcessingPipeline` برای اجرای بهتر پردازش‌ها**  

```python
class ProcessingOptimizer:
    def allocate_resources(self, complexity: str) -> bool:
        """ تخصیص منابع پردازشی بر اساس سطح پیچیدگی وظیفه. """
```

---

## 🎯 **نتیجه‌گیری**
ماژول `processing/` **هسته‌ی پردازشی سیستم را تشکیل می‌دهد و تمامی درخواست‌های پردازشی را بر اساس پیچیدگی وظیفه و منابع در دسترس مدیریت می‌کند.**  
✅ **`pipeline.py` مسئول کنترل فرآیند پردازش و اجرای سه سطح پردازش است.**  
✅ **`task_scheduler.py` وظایف پردازشی را زمان‌بندی کرده و توزیع بار پردازشی را مدیریت می‌کند.**  
✅ **`optimizer.py` تخصیص منابع را بهینه کرده و مصرف منابع را مدیریت می‌کند.**  


✅ **بخش هفتم: مستندات `core/quality/` (کنترل کیفیت، تحلیل متریک‌ها، و بهبود عملکرد مدل‌ها)**  

📌 **هدف این بخش:**  
- **بررسی ماژول `quality/` و نقش آن در `core/`**  
- **توضیح ساختار فایل‌های `quality/`**  
- **شرح کلاس‌های کلیدی، متدها، و مکانیزم‌های کنترل کیفیت مدل‌ها**  

🚀 **این بخش، سیستم ارزیابی و بهبود کیفیت مدل‌های هوش مصنوعی را توضیح می‌دهد که شامل تحلیل متریک‌ها، بررسی بازخورد کاربران، و تنظیمات تطبیقی برای بهینه‌سازی مدل‌ها است.**  

---

### **📜 مستندات `core/quality/`**
```md
# 📌 مستندات `core/quality/` - کنترل کیفیت و بهینه‌سازی مدل‌های هوش مصنوعی

## 1️⃣ مقدمه
ماژول `core/quality/` مسئول **پایش کیفیت مدل‌های فدراسیونی، تحلیل متریک‌های عملکردی، و بهبود مستمر مدل‌ها** است.  
این ماژول تضمین می‌کند که **کیفیت پاسخ‌های مدل‌های هوش مصنوعی از طریق تحلیل دقیق متریک‌ها و دریافت بازخورد کاربران بهینه شود.**

---

## 2️⃣ نقش `quality/` در سیستم
📌 **وظایف کلیدی `quality/`**  
✅ **تحلیل کیفیت پاسخ مدل‌های فدراسیونی و بررسی دقت، انسجام، و سازگاری زمینه‌ای**  
✅ **جمع‌آوری و تحلیل متریک‌های عملکردی مدل‌ها از جمله دقت، تأخیر، و مصرف منابع**  
✅ **بهینه‌سازی کیفیت مدل‌ها بر اساس داده‌های متریک و تحلیل بازخورد کاربران**  
✅ **ارائه‌ی پیشنهادات خودکار برای بهینه‌سازی مدل‌ها و افزایش دقت پاسخ‌ها**  

---

## 3️⃣ ساختار `core/quality/`
```plaintext
core/
└── quality/
    ├── evaluation/             # ارزیابی کیفیت خروجی مدل‌ها
    │   ├── quality_evaluator.py     # تحلیل معنایی، انسجام، و سازگاری زمینه‌ای
    │
    ├── metrics/                # تحلیل متریک‌های عملکردی مدل‌ها
    │   ├── performance_metrics.py   # ثبت و تحلیل متریک‌های دقت، تأخیر، و مصرف منابع
    │
    ├── optimization/           # بهبود کیفیت مدل‌ها بر اساس داده‌های تحلیلی
    │   ├── quality_optimizer.py      # بهینه‌سازی کیفیت پردازش مدل‌ها
    │   ├── feedback_analyzer.py      # تحلیل بازخورد کاربران برای بهبود سیستم
```

---

## 4️⃣ بررسی فایل‌های `quality/`

### 📍 **`evaluation/` - ارزیابی کیفیت پاسخ مدل‌ها**
📌 **ویژگی‌های کلیدی:**  
✅ **`quality_evaluator.py`** → تحلیل معنایی، بررسی انسجام، و ارزیابی سازگاری پاسخ‌ها با زمینه  

```python
class QualityEvaluator:
    def evaluate_response(self, response: str, context: Dict[str, Any], requirements: Dict[str, Any]) -> Dict[str, float]:
        """تحلیل جامع کیفیت پاسخ مدل شامل دقت، انسجام، و سازگاری زمینه‌ای"""
```

---

### 📍 **`metrics/` - تحلیل متریک‌های عملکردی**
📌 **ویژگی‌های کلیدی:**  
✅ **`performance_metrics.py`** → جمع‌آوری متریک‌های دقت، تأخیر، و مصرف منابع مدل‌های فدراسیونی  

```python
class PerformanceMetrics:
    def record_performance_metrics(self, model_id: str, accuracy: float, latency: float, resource_usage: Dict[str, float]):
        """ثبت متریک‌های عملکردی یک مدل فدراسیونی"""
```

---

### 📍 **`optimization/` - بهینه‌سازی کیفیت مدل‌ها**
📌 **ویژگی‌های کلیدی:**  
✅ **`quality_optimizer.py`** → تنظیم و بهینه‌سازی مدل‌ها بر اساس داده‌های ارزیابی کیفیت  
✅ **`feedback_analyzer.py`** → تحلیل بازخورد کاربران و بهینه‌سازی مدل‌های هوش مصنوعی بر اساس داده‌های تجربی  

```python
class QualityOptimizer:
    def optimize_model_quality(self, model_id: str, quality_metrics: Dict[str, float]) -> Dict[str, Any]:
        """بهینه‌سازی کیفیت پردازش مدل بر اساس تحلیل متریک‌های کیفیت"""
```

---

## 🎯 **نتیجه‌گیری**
ماژول `quality/` **هسته‌ی ارزیابی و بهینه‌سازی مدل‌های فدراسیونی را تشکیل می‌دهد و تضمین می‌کند که کیفیت پاسخ‌ها، متریک‌های عملکردی، و تنظیمات مدل‌ها بهینه شوند.**  
✅ **`evaluation/` تحلیل دقیق کیفیت پاسخ مدل‌ها را مدیریت می‌کند.**  
✅ **`metrics/` متریک‌های عملکردی مدل‌ها را ثبت و تحلیل می‌کند.**  
✅ **`optimization/` مدل‌ها را بر اساس داده‌های متریک و بازخورد کاربران بهینه می‌کند.**  


✅ **بخش هشتم: مستندات `core/resource_management/` (مدیریت تخصیص منابع، توزیع بار پردازشی، و کنترل مصرف منابع)**  

📌 **هدف این بخش:**  
- **بررسی ماژول `resource_management/` و نقش آن در `core/`**  
- **توضیح ساختار فایل‌های `resource_management/`**  
- **شرح کلاس‌های کلیدی، متدها، و مکانیزم‌های مدیریت منابع پردازشی**  

🚀 **این بخش، سیستم مدیریت منابع را توضیح می‌دهد که شامل تخصیص منابع پردازشی، توزیع بار، و کنترل مصرف CPU، حافظه، و GPU است.**  

---

### **📜 مستندات `core/resource_management/`**
```md
# 📌 مستندات `core/resource_management/` - مدیریت منابع پردازشی و توزیع بار

## 1️⃣ مقدمه
ماژول `core/resource_management/` مسئول **مدیریت تخصیص منابع، توزیع بار پردازشی، و نظارت بر مصرف منابع سیستم** است.  
این ماژول تضمین می‌کند که **وظایف پردازشی به‌صورت بهینه به منابع اختصاص داده شوند و از اضافه‌بار پردازشی جلوگیری شود.**  

---

## 2️⃣ نقش `resource_management/` در سیستم
📌 **وظایف کلیدی `resource_management/`**  
✅ **مدیریت تخصیص منابع پردازشی (CPU، حافظه، GPU) برای پردازش وظایف**  
✅ **متعادل‌سازی بار پردازشی بین مدل‌های پردازشی**  
✅ **کنترل و پایش مصرف منابع پردازشی سیستم**  
✅ **مدیریت سهمیه‌ی منابع برای جلوگیری از مصرف بیش‌ازحد یک مدل خاص**  
✅ **تحلیل روند استفاده از منابع و تنظیمات تطبیقی برای بهینه‌سازی تخصیص منابع**  

---

## 3️⃣ ساختار `core/resource_management/`
```plaintext
core/
└── resource_management/
    ├── allocator/                 # تخصیص منابع پردازشی (CPU، حافظه، GPU)
    │   ├── cpu_allocator.py       # مدیریت تخصیص CPU برای پردازش وظایف
    │   ├── memory_allocator.py    # مدیریت تخصیص حافظه و منابع RAM
    │   ├── gpu_allocator.py       # مدیریت تخصیص GPU برای پردازش مدل‌ها
    │
    ├── monitor/                   # پایش مصرف منابع و تحلیل روند استفاده
    │   ├── resource_monitor.py    # پایش مصرف منابع پردازشی سیستم
    │   ├── threshold_manager.py   # تنظیم آستانه‌های مصرف منابع برای هشدارها
    │   ├── alert_generator.py     # ارسال هشدار در صورت مصرف بیش‌ازحد منابع
    │
    ├── optimizer/                 # بهینه‌سازی تخصیص منابع و توزیع بار پردازشی
    │   ├── resource_optimizer.py  # بهینه‌سازی مصرف منابع بر اساس داده‌های عملکردی
    │   ├── load_balancer.py       # متعادل‌سازی بار بین مدل‌های پردازشی
    │
    ├── quota_manager.py           # مدیریت سهمیه منابع برای مدل‌ها
```

---

## 4️⃣ بررسی فایل‌های `resource_management/`

### 📍 **`allocator/` - تخصیص منابع پردازشی**
📌 **ویژگی‌های کلیدی:**  
✅ **`cpu_allocator.py`** → تخصیص پردازنده برای پردازش وظایف مختلف  
✅ **`memory_allocator.py`** → مدیریت و تخصیص حافظه RAM برای پردازش مدل‌ها  
✅ **`gpu_allocator.py`** → تخصیص GPU برای پردازش‌های سنگین مدل‌های یادگیری عمیق  

```python
class CPUAllocator:
    def allocate(self, model_id: str, cpu_units: float) -> bool:
        """ تخصیص CPU برای یک مدل پردازشی. """
```

---

### 📍 **`monitor/` - پایش مصرف منابع و تحلیل روند استفاده**
📌 **ویژگی‌های کلیدی:**  
✅ **`resource_monitor.py`** → بررسی مصرف CPU، حافظه، و GPU توسط مدل‌ها  
✅ **`threshold_manager.py`** → تنظیم آستانه‌های مصرف منابع برای جلوگیری از اضافه‌بار پردازشی  
✅ **`alert_generator.py`** → ارسال هشدار در صورت مصرف بیش‌ازحد منابع  

```python
class ResourceMonitor:
    def collect_metrics(self, model_id: str) -> Dict[str, float]:
        """ جمع‌آوری متریک‌های مصرف منابع مدل. """
```

---

### 📍 **`optimizer/` - بهینه‌سازی تخصیص منابع و توزیع بار پردازشی**
📌 **ویژگی‌های کلیدی:**  
✅ **`resource_optimizer.py`** → تنظیم منابع پردازشی برای جلوگیری از هدررفت منابع  
✅ **`load_balancer.py`** → توزیع بار پردازشی بین مدل‌های پردازشی برای جلوگیری از اضافه‌بار پردازشی  

```python
class LoadBalancer:
    def distribute_load(self, task_list: List[Dict[str, Any]]) -> Dict[str, str]:
        """ توزیع وظایف پردازشی بین مدل‌های پردازشی. """
```

---

### 📍 **`quota_manager.py` - مدیریت سهمیه منابع برای مدل‌ها**
📌 **ویژگی‌های کلیدی:**  
✅ **تخصیص منابع بر اساس سهمیه‌ی مدل‌ها**  
✅ **جلوگیری از مصرف بیش‌ازحد منابع توسط یک مدل خاص**  
✅ **امکان تغییر سهمیه‌ها بر اساس روند استفاده و نیاز مدل‌ها**  

```python
class QuotaManager:
    def set_quota(self, model_id: str, cpu: float, memory: int, gpu: float):
        """ تنظیم سهمیه‌ی منابع برای مدل پردازشی. """
```

---

## 🎯 **نتیجه‌گیری**
ماژول `resource_management/` **وظیفه‌ی مدیریت تخصیص منابع، توزیع بار پردازشی، و کنترل مصرف منابع پردازشی را بر عهده دارد.**  
✅ **`allocator/` مدیریت تخصیص CPU، حافظه، و GPU را انجام می‌دهد.**  
✅ **`monitor/` روند استفاده از منابع را تحلیل کرده و هشدارهای لازم را ارسال می‌کند.**  
✅ **`optimizer/` منابع پردازشی را بهینه‌سازی کرده و بار پردازشی را متعادل می‌کند.**  
✅ **`quota_manager.py` تضمین می‌کند که مصرف منابع برای مدل‌ها عادلانه و بهینه باشد.**  

```

# 📌 مستندات ماژول Models/Services در Smart Whale AI

## 🏗️ مقدمه
ماژول `models/services` قلب پیام‌رسانی و ارتباطات مدل‌های هوش مصنوعی در سیستم Smart Whale است. این ماژول با تمرکز بر اصل "ارتباط کارآمد، همکاری هوشمند" طراحی شده است و مجموعه‌ای از سرویس‌های قدرتمند را برای مدیریت ارتباطات بین مدل‌ها، کاربران و سایر ماژول‌های سیستم ارائه می‌دهد. این ماژول امکان اشتراک‌گذاری دانش بین مدل‌ها، استریم پاسخ به کاربران، و درخواست داده از ماژول بالانس را با رویکردی یکپارچه و کارآمد فراهم می‌کند.

## 📦 ساختار ماژول
```bash
models/services/
├── federation_service.py        # مدیریت ارتباط فدراسیونی بین مدل‌ها
├── user_service.py              # مدیریت ارتباط با کاربر و استریم پاسخ‌ها
├── data_request_service.py      # مدیریت درخواست‌های داده از ماژول بالانس
├── messaging_service.py         # سرویس مرکزی هماهنگ‌کننده پیام‌رسانی
└── __init__.py                  # صادرسازی سرویس‌ها برای استفاده در سایر بخش‌ها
```

## 🔄 نقش `models/services` در سیستم

**ماژول `models/services` مسئولیت مدیریت تمام ارتباطات و پیام‌رسانی‌های مدل‌های هوش مصنوعی را بر عهده دارد، از جمله:**

- **ارتباط فدراسیونی بین مدل‌ها** برای اشتراک دانش و همکاری
- **استریم پاسخ‌ها به کاربران** به‌صورت سلسله‌مراتبی و بلادرنگ
- **ارسال درخواست‌های داده** به ماژول بالانس و دریافت پاسخ‌ها
- **هماهنگی بین سرویس‌ها** به‌عنوان یک لایه واسط یکپارچه

## 📚 شرح تفصیلی سرویس‌ها

### 1️⃣ سرویس فدراسیون (FederationService) - فایل `federation_service.py`

**هدف**: مدیریت ارتباط فدراسیونی بین مدل‌ها، اشتراک‌گذاری دانش و همکاری در حل مسائل پیچیده.

#### ویژگی‌ها و عملکردها:

- **مدیریت ارتباط بین مدل‌ها**
  - ثبت مدل‌ها در سیستم فدراسیون با `register_model`
  - اشتراک در پیام‌های فدراسیونی با `subscribe_to_federation`
  - مدیریت موضوعات اختصاصی برای هر مدل

- **اشتراک‌گذاری دانش**
  - تبادل اطلاعات بین مدل‌ها با حفظ حریم خصوصی با `share_knowledge`
  - تنظیم سطوح مختلف حریم خصوصی (استاندارد، ناشناس، رمزگذاری شده)
  - امکان اشتراک‌گذاری دانش با یک مدل خاص یا همه مدل‌ها

- **همکاری در حل مسائل**
  - درخواست همکاری از سایر مدل‌ها با `request_collaboration`
  - پاسخ به درخواست‌های همکاری با `respond_to_collaboration`
  - مدیریت زمان‌بندی و انقضای درخواست‌های همکاری

#### متدهای کلیدی:

- **`initialize()`** - آماده‌سازی اولیه سرویس فدراسیون
- **`register_model(model_id, handler)`** - ثبت مدل در سیستم فدراسیون
- **`share_knowledge(source_model_id, target_model_id, knowledge_data, ...)`** - اشتراک دانش بین مدل‌ها
- **`subscribe_to_federation(model_id, handler)`** - اشتراک در پیام‌های فدراسیونی
- **`request_collaboration(source_model_id, problem_data, ...)`** - درخواست همکاری از مدل‌های دیگر
- **`respond_to_collaboration(source_model_id, target_model_id, ...)`** - پاسخ به درخواست همکاری
- **`get_collaboration_status(request_id)`** - دریافت وضعیت یک درخواست همکاری

### 2️⃣ سرویس کاربر (UserService) - فایل `user_service.py`

**هدف**: مدیریت ارتباط با کاربر، ثبت و مدیریت نشست‌ها، و استریم کردن پاسخ‌های مدل‌ها به کاربران.

#### ویژگی‌ها و عملکردها:

- **مدیریت نشست کاربر**
  - ایجاد نشست جدید با `register_user_session`
  - نگهداری اطلاعات نشست و مدل مرتبط با آن
  - پایان دادن به نشست با `end_user_session`

- **استریم پاسخ به کاربر**
  - ارسال تدریجی (استریم) پاسخ مدل با `stream_response`
  - پشتیبانی از ارسال فرآیند تفکر مدل با `send_thinking_process`
  - مدیریت بخش‌های مختلف پاسخ و تعیین پایان پاسخ

- **دریافت درخواست‌های کاربر**
  - پردازش درخواست‌های ورودی کاربر با `receive_user_request`
  - اشتراک مدل‌ها در درخواست‌های کاربر با `subscribe_to_user_requests`

#### متدهای کلیدی:

- **`initialize()`** - آماده‌سازی اولیه سرویس کاربر
- **`register_user_session(session_id, model_id, ...)`** - ثبت نشست جدید کاربر
- **`stream_response(session_id, response_chunk, ...)`** - استریم بخشی از پاسخ به کاربر
- **`send_thinking_process(session_id, thinking_data, ...)`** - ارسال فرآیند تفکر مدل
- **`receive_user_request(session_id, request_text, ...)`** - دریافت و پردازش درخواست کاربر
- **`subscribe_to_user_requests(model_id, handler)`** - اشتراک مدل در درخواست‌های کاربر
- **`end_user_session(session_id, reason)`** - پایان دادن به نشست کاربر
- **`get_session_info(session_id)`** - دریافت اطلاعات نشست کاربر

### 3️⃣ سرویس درخواست داده (DataRequestService) - فایل `data_request_service.py`

**هدف**: مدیریت درخواست‌های داده از ماژول بالانس، پیگیری وضعیت درخواست‌ها و پردازش پاسخ‌های دریافتی.

#### ویژگی‌ها و عملکردها:

- **ارسال درخواست داده**
  - فرمت‌بندی و ارسال درخواست داده با `request_data`
  - ارسال درخواست‌های دسته‌ای با `request_batch`
  - تخمین زمان پردازش درخواست‌ها

- **پیگیری وضعیت درخواست‌ها**
  - ثبت و پیگیری درخواست‌های در حال انتظار
  - دریافت وضعیت درخواست با `get_request_status`
  - امکان لغو درخواست‌های در حال انتظار با `cancel_request`

- **دریافت و پردازش پاسخ‌ها**
  - اشتراک در موضوع پاسخ‌های داده با `subscribe_to_data_responses`
  - پردازش پاسخ‌های دریافتی با پردازشگرهای سفارشی

#### متدهای کلیدی:

- **`initialize()`** - آماده‌سازی اولیه سرویس درخواست داده
- **`request_data(model_id, query, ...)`** - ارسال درخواست جمع‌آوری داده
- **`request_batch(model_id, queries)`** - ارسال چندین درخواست به صورت دسته‌ای
- **`subscribe_to_data_responses(model_id, handler)`** - اشتراک در موضوع پاسخ‌های داده
- **`get_request_status(request_id)`** - دریافت وضعیت یک درخواست داده
- **`cancel_request(request_id)`** - لغو یک درخواست داده در حال انتظار
- **`_estimate_processing_time(source_type, parameters)`** - تخمین زمان پردازش درخواست

### 4️⃣ سرویس پیام‌رسانی (MessagingService) - فایل `messaging_service.py`

**هدف**: هماهنگی بین تمام سرویس‌های پیام‌رسانی و ارائه یک رابط یکپارچه برای مدیریت ارتباطات.

#### ویژگی‌ها و عملکردها:

- **هماهنگی بین سرویس‌ها**
  - مدیریت ارتباط با سرویس‌های فدراسیون، کاربر و درخواست داده
  - راه‌اندازی و توقف هماهنگ تمام سرویس‌ها
  - ارائه رابط یکپارچه برای تعامل با سیستم پیام‌رسانی

- **ثبت و مدیریت مدل‌ها**
  - ثبت مدل در تمام سرویس‌های پیام‌رسانی با `register_model`
  - مدیریت پردازشگرهای سفارشی برای هر مدل

- **انتشار متریک‌ها و رویدادها**
  - انتشار متریک‌های عملکردی مدل‌ها با `publish_metric`
  - انتشار رویدادهای مرتبط با مدل‌ها با `publish_event`

#### متدهای کلیدی:

- **`initialize()`** - آماده‌سازی اولیه سرویس پیام‌رسانی و راه‌اندازی سرویس‌های وابسته
- **`register_model(model_id, ...)`** - ثبت مدل در تمام سرویس‌های پیام‌رسانی
- **`request_data(model_id, query, ...)`** - ارسال درخواست داده از طریق سرویس درخواست داده
- **`request_batch_data(model_id, queries)`** - ارسال درخواست‌های دسته‌ای داده
- **`share_knowledge(source_model_id, ...)`** - اشتراک دانش بین مدل‌ها از طریق سرویس فدراسیون
- **`request_collaboration(source_model_id, ...)`** - درخواست همکاری از مدل‌های دیگر
- **`respond_to_collaboration(source_model_id, ...)`** - پاسخ به درخواست همکاری
- **`stream_response(session_id, ...)`** - استریم پاسخ به کاربر از طریق سرویس کاربر
- **`send_thinking_process(session_id, ...)`** - ارسال فرآیند تفکر مدل به کاربر
- **`register_user_session(session_id, ...)`** - ثبت نشست کاربر
- **`end_user_session(session_id, ...)`** - پایان دادن به نشست کاربر
- **`publish_metric(model_id, ...)`** - انتشار متریک عملکردی مدل
- **`publish_event(model_id, ...)`** - انتشار رویداد مرتبط با مدل
- **`run()`** - اجرای سرویس پیام‌رسانی و ورود به حلقه اصلی
- **`shutdown()`** - توقف سرویس پیام‌رسانی و آزادسازی منابع

### 5️⃣ صادرسازی سرویس‌ها (__init__.py) - فایل `__init__.py`

**هدف**: صادرسازی سرویس‌های ماژول `models/services` برای استفاده در سایر بخش‌های سیستم.

#### موارد صادر شده:

- **کلاس‌های سرویس**
  - `FederationService` - کلاس سرویس فدراسیون
  - `UserService` - کلاس سرویس کاربر
  - `DataRequestService` - کلاس سرویس درخواست داده
  - `MessagingService` - کلاس سرویس پیام‌رسانی

- **نمونه‌های Singleton**
  - `federation_service` - نمونه سرویس فدراسیون
  - `user_service` - نمونه سرویس کاربر
  - `data_request_service` - نمونه سرویس درخواست داده
  - `messaging_service` - نمونه سرویس پیام‌رسانی

## 🔄 تعامل بین سرویس‌ها

### ارتباط بین سرویس‌های مدل
1. **MessagingService** به عنوان نقطه ورودی اصلی، هماهنگی بین تمام سرویس‌های دیگر را انجام می‌دهد.
2. **FederationService** برای ارتباط بین مدل‌ها استفاده می‌شود و امکان اشتراک دانش و همکاری را فراهم می‌آورد.
3. **UserService** ارتباط با کاربر را مدیریت می‌کند و پاسخ‌های تولیدشده توسط مدل را به صورت استریم به کاربر ارسال می‌کند.
4. **DataRequestService** درخواست‌های داده را به ماژول بالانس ارسال کرده و پاسخ‌ها را دریافت و پردازش می‌کند.

### ارتباط با سایر ماژول‌ها
1. **ارتباط با ماژول بالانس**:
   - ارسال درخواست‌های داده از طریق `DataRequestService`
   - دریافت نتایج از طریق موضوعات اختصاصی مدل

2. **ارتباط با ماژول هسته (core)**:
   - استفاده از `kafka_service` برای ارتباطات کافکا
   - استفاده از `TopicManager` برای مدیریت موضوعات
   - استفاده از انواع داده و ساختارهای پیام تعریف‌شده در ماژول هسته

### نمودار جریان داده در ماژول `models/services`
```bash
┌────────────┐         ┌─────────────────┐         ┌───────────────┐
│   کاربر    │◄────────┤  UserService    │◄────────┤ MessagingService │
└────────────┘         └─────────────────┘         └───────┬───────┘
                                                          │
                       ┌─────────────────┐               │
                       │ FederationService │◄─────────────┤
                       └─────────────────┘               │
                                                         │
                       ┌─────────────────┐               │
                       │DataRequestService│◄─────────────┘
                       └────────┬────────┘
                                │
                                ▼
                       ┌─────────────────┐
                       │  ماژول بالانس   │
                       └─────────────────┘
```

## 📊 استراتژی‌های بهینه‌سازی و عملکرد

### 1. بهینه‌سازی ارتباطات
- **اتصال‌های غیرهمزمان**:  
  استفاده از الگوی async/await برای تمام عملیات‌های I/O-bound برای عدم بلوک کردن اجرا.
  
- **پردازش دسته‌ای**:  
  ارائه متدهای دسته‌ای مانند `request_batch` برای کاهش overhead ارتباطات.
  
- **استریم پاسخ‌ها**:  
  ارسال تدریجی پاسخ‌ها به کاربر برای تجربه کاربری بهتر و مصرف بهینه منابع.

### 2. مدیریت منابع
- **الگوی Singleton**:  
  استفاده از نمونه‌های singleton برای تمام سرویس‌ها جهت کاهش مصرف منابع.
  
- **مدیریت هوشمند اتصال‌های کافکا**:  
  اشتراک‌گذاری اتصال‌های کافکا و مدیریت صحیح آن‌ها برای کاهش بار.
  
- **زمان‌بندی هوشمند منابع**:  
  تخمین زمان پردازش درخواست‌ها و برنامه‌ریزی بهینه منابع.

### 3. قابلیت توسعه و انعطاف‌پذیری
- **طراحی ماژولار**:  
  جداسازی مسئولیت‌ها به سرویس‌های مجزا برای قابلیت توسعه بهتر.
  
- **پردازشگرهای سفارشی**:  
  امکان تعریف پردازشگرهای اختصاصی برای هر مدل جهت انعطاف‌پذیری بیشتر.
  
- **ثبت لاگ دقیق**:  
  لاگ‌گذاری کامل برای نظارت بهتر و عیب‌یابی سریع‌تر.

### 4. امنیت و قابلیت اطمینان
- **مدیریت خطا**:  
  پیاده‌سازی مکانیزم‌های مدیریت خطای جامع در تمام سطوح.
  
- **تلاش مجدد خودکار**:  
  پیاده‌سازی مکانیزم‌های تلاش مجدد برای عملیات‌های ناموفق.
  
- **زمان انقضا برای درخواست‌ها**:  
  تعیین زمان انقضا برای درخواست‌های همکاری و داده جهت جلوگیری از انباشت درخواست‌های معلق.

## 🎯 نتیجه‌گیری

ماژول `models/services` **مغز ارتباطی سیستم Smart Whale AI است** که با **مدیریت تمام انواع ارتباطات مدل‌های هوش مصنوعی**، امکان **اشتراک دانش بین مدل‌ها**، **استریم پاسخ به کاربران**، و **دریافت داده از منابع خارجی** را فراهم می‌کند.

این ماژول با طراحی ماژولار و انعطاف‌پذیر خود، **قابلیت توسعه و مقیاس‌پذیری بالایی** دارد و می‌تواند به راحتی با افزودن مدل‌های جدید یا انواع جدید ارتباطات گسترش یابد.

استفاده از **الگوهای طراحی کارآمد**، **مدیریت بهینه منابع**، و **بهره‌گیری از ارتباطات غیرهمزمان** باعث می‌شود که این ماژول با وجود پیچیدگی‌های درونی، **عملکرد بالا و پایداری قابل توجهی** داشته باشد.

با استفاده از این ماژول، مدل‌های هوش مصنوعی می‌توانند **به صورت فدراسیونی همکاری کنند**، **داده‌های مورد نیاز خود را از منابع مختلف دریافت کنند** و **پاسخ‌های خود را به صورت بلادرنگ به کاربران ارائه دهند**، که همه این موارد به **تجربه کاربری بهتر و کارایی بالاتر سیستم** منجر می‌شود.

